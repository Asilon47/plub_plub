"""Core odometry maths for a four-wheel mecanum base.

Translates accumulated encoder ticks into a planar pose (x, y, yaw)
plus velocities.
"""

from __future__ import division
from math import pi, sin, cos

from mecanum_drive.encoder import Encoder
from mecanum_drive.pose import Pose


class Odometry:
    """Tracks robot pose using four wheel encoders."""

    def __init__(self):
        # One incremental encoder per wheel
from __future__ import division
from math import pi, sin, cos
from mecanum_drive.encoder import Encoder
from mecanum_drive.pose import Pose

class Odometry:
    """Keeps track of the current position and velocity of a
    robot using differential drive.
    """

    def __init__(self):
        self.frontLeftEncoder = Encoder()
        self.frontRightEncoder = Encoder()
        self.rearLeftEncoder = Encoder()
        self.rearRightEncoder = Encoder()

        # Current pose estimate
        self.pose = Pose()

        # Time (s) of last update, set by node
        self.lastTime = 0

    # --- Parameter setters -------------------------------------------------

    def setWheelSeparation(self, separation):
        """Half-width of the chassis (m)."""
        self.wheelSeparation = separation

    def setWheelSeparationLength(self, separation):
        """Half-length of the chassis (m)."""
        self.wheelSeparationLength = separation

    def setTicksPerMeter(self, ticks):
        """Encoder resolution: ticks generated by 1Â m of wheel travel."""
        self.ticksPerMeter = ticks

    def setEncoderRange(self, low, high):
        """Configure wrap-around range for all four encoders."""
        self.pose = Pose()
        self.lastTime = 0

    def setWheelSeparation(self, separation):
        self.wheelSeparation = separation

    def setWheelSeparationLength(self, separation):
        self.wheelSeparationLength = separation

    def setTicksPerMeter(self, ticks):
        self.ticksPerMeter = ticks
        
    def setEncoderRange(self, low, high):
        self.frontLeftEncoder.setRange(low, high)
        self.frontRightEncoder.setRange(low, high)
        self.rearLeftEncoder.setRange(low, high)
        self.rearRightEncoder.setRange(low, high)

    def setTime(self, newTime):
        """Initialise the timestamp used for velocity calculations (s)."""
        self.lastTime = newTime

    # --- Encoder updates ---------------------------------------------------

    def updateWheels(self, fl, fr, rl, rr):
        """Push latest raw encoder counts (signed ints) for each wheel."""
        self.frontLeftEncoder.update(fl)
        self.frontRightEncoder.update(fr)
        self.rearLeftEncoder.update(rl)
        self.rearRightEncoder.update(rr)

    # --- Pose update -------------------------------------------------------

    def updatePose(self, newTime):
        """Integrate wheel travel since last call and update the pose."""
        # Convert tick deltas to distance (m)
        self.lastTime = newTime
        
    def updateWheels(self, fl, fr, rl, rr):
        self.frontLeftEncoder.update(fl)
        self.frontRightEncoder.update(fr)        
        self.rearLeftEncoder.update(rl)        
        self.rearRightEncoder.update(rr)        

    def updatePose(self, newTime):
        """Updates the pose based on the accumulated encoder ticks
        of the four mecanum wheels.
        """
        frontLeftTravel = self.frontLeftEncoder.getDelta() / self.ticksPerMeter
        frontRightTravel = self.frontRightEncoder.getDelta() / self.ticksPerMeter
        rearLeftTravel = self.rearLeftEncoder.getDelta() / self.ticksPerMeter
        rearRightTravel = self.rearRightEncoder.getDelta() / self.ticksPerMeter

        deltaTime = newTime - self.lastTime

        # Standard mecanum inverse kinematics in robot frame (m, rad)
        deltaXTravel = (frontLeftTravel + frontRightTravel + rearLeftTravel + rearRightTravel) / 4.0
        deltaYTravel = (-frontLeftTravel + frontRightTravel + rearLeftTravel - rearRightTravel) / 4.0
        deltaTheta = (
            -frontLeftTravel + frontRightTravel - rearLeftTravel + rearRightTravel
        ) / (2 * (self.wheelSeparation + self.wheelSeparationLength))

        # Rotate to world frame and integrate
        self.pose.x += deltaXTravel * cos(self.pose.theta) - deltaYTravel * sin(self.pose.theta)
        self.pose.y += deltaYTravel * cos(self.pose.theta) + deltaXTravel * sin(self.pose.theta)
        self.pose.theta = (self.pose.theta + deltaTheta) % (2 * pi)

        # Derive velocities (m/s, rad/s)
        self.pose.xVel = deltaXTravel / deltaTime if deltaTime > 0 else 0.0
        self.pose.yVel = deltaYTravel / deltaTime if deltaTime > 0 else 0.0
        self.pose.thetaVel = deltaTheta / deltaTime if deltaTime > 0 else 0.0

        self.lastTime = newTime

    # --- Accessors ---------------------------------------------------------

    def getPose(self):
        return self.pose
        deltaTime = newTime - self.lastTime

        deltaXTravel = (frontLeftTravel + frontRightTravel + rearLeftTravel + rearRightTravel) / 4.0
        deltaYTravel = (-frontLeftTravel + frontRightTravel + rearLeftTravel - rearRightTravel) / 4.0
        deltaTheta = (-frontLeftTravel + frontRightTravel - rearLeftTravel + rearRightTravel) / (2 * (self.wheelSeparation + self.wheelSeparationLength))

        self.pose.x += deltaXTravel*cos(self.pose.theta) - deltaYTravel*sin(self.pose.theta)
        self.pose.y += deltaYTravel*cos(self.pose.theta) + deltaXTravel*sin(self.pose.theta)
        self.pose.theta = (self.pose.theta + deltaTheta) % (2*pi)
        self.pose.xVel = deltaXTravel / deltaTime if deltaTime > 0 else 0.
        self.pose.yVel = deltaYTravel / deltaTime if deltaTime > 0 else 0.
        self.pose.thetaVel = deltaTheta / deltaTime if deltaTime > 0 else 0.

        self.lastTime = newTime

    def getPose(self):
        return self.pose;

    def setPose(self, newPose):
        self.pose = newPose
